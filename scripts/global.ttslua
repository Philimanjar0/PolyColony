----------------------------------------- INCLUDES -----------------------------------------------------------------
#include Complete_Catan/scripts/snaps
#include Complete_Catan/scripts/models
#include Complete_Catan/scripts/boarders
#include Complete_Catan/scripts/land_placements
#include Complete_Catan/scripts/available_resources

probabilityPositions = {}
resProbDistribution = {} -- getBalancedProbs
probabilityList = {} --buildSortedProbs
resourceList = {} --get balanced board
placedResourceObjects = {} --place terrain
placedProbabilityObjects = {} --place probs
tilePositions = {}
boarderPositions = {}


numWood = 4
numClay = 3
numSheep = 4
numWheat = 4
numOre = 3
numDesert = 1

totalResources = 18
totalReturn = 58
----------------------------------------- AUTOMATIC FUNCTIONS ------------------------------------------------------
function onSave()
    --local data_to_save = {}
    --saved_data = JSON.encode(data_to_save)
    --saved_data = "" --Remove -- at start + save to clear save data
    --return saved_data
end

function onLoad(saved_data)
    calculateBoardSpecs()
    --log(dump(getCoastalNeighborIndeces(tilePositions,boarder_small,2)))
end

function onUpdate()
    --called every frame
end

--------------------------------------- DEFINED FUNCTIONS ---------------------------------------------------------

-- buildProbList(returnList, resourceList, probByResource)
--main functin called from UI to call other generation functions
function generate(_,_,idValue)
    placeBoarder(0)
    calculateBoardSpecs()
    --tilePositions = deepcopy(land_small)


    --I know this is jank, but i am not sure how to combine the two functions
    --in such a way that can recursively place both terrain and numbers
    local counter = 0
    while probabilityList == nil or #probabilityList == 0  do
        resourceList = getBalancedBoard(resources_small,{},{})
        resProbDistribution = getBalancedProbs(probabilities_small)
        if(resProbDistribution ~= nil) then
            probabilityList = buildProbList({}, resourceList, resProbDistribution)
        end
        counter = counter +1
        if counter > 10 then
            print('Generation timed out, please regenerate')
            return -1
        end
    end
    --log("counter: ", counter)
    placedResourceObjects = placeTerrain(resourceList,tilePositions)
    placedProbabilityObjects = placeProbs(probabilityList, placedResourceObjects, resourceList)

    --placePorts(idValue)
    local inter =buildPortPositionArray(boarderPositions)
    log(dump(inter))
    local doubleinter = buildPortArray(inter,FYShuffle(avail_trade_small),{})
    log(dump(doubleinter))
    local portObjectList = placePorts(doubleinter)
    placeTradeTokens(removeZeros(doubleinter),portObjectList)



end

function calculateBoardSpecs()
    probabilityList = {}
    tilePositions = deepcopy(land_small)
    boarderPositions = deepcopy(boarder_small)
end

--places water boarder given board size
function placeBoarder(size)
    print('placing boarder...')
    local boarderArray = {}
    local defaultLayout = boarderPositions
    if size == '1' then
        defaultLayout = boarder_medium
    end
    if size == '2' then
        defaultLayout = boarder_large
    end
    for index,i in pairs(defaultLayout) do
        boarderArray[index] = spawnObject(tileParams)
        boarderArray[index].setCustomObject(ocean)
        boarderArray[index].setPosition({i[1],0.96,i[2]})
        boarderArray[index].setRotation({0,60*math.random(6),0})
        boarderArray[index].setSnapPoints(concat(tileSnap,{}))
        boarderArray[index].setLock(true)
    end
    print('boarder placed')
end

------------------------------------------------start here----------------------

--returned array is of form {{direction,resource},{direction,resource}}
--where direction is 1,2,3,4,5,6 starting facing tl and rotates cw
function buildPortArray(oldboarder,availableTrades,returnList)

    function canPlace(boarderIndex,direction,tradeToTest)
        local indecesToTest = getCoastalNeighborIndeces(tilePositions,boarderPositions,boarderIndex)
        local directionWeights = {}
        for i,num in pairs(getCoastalNeighborDirections(tilePositions,boarderPositions,boarderIndex)) do
            if num == direction then
                table.insert(directionWeights,2)
            else
                table.insert(directionWeights,1)
            end
        end

        for i,num in pairs(indecesToTest) do
            if probabilityList[num] == 0 then
                directionWeights[i] = 0
                return true -- this means it is next to desert, can place anything here
            elseif tradeToTest == DESERT then
                directionWeights[i] = directionWeights[i]*2*probability_map[probabilityList[num]]
            elseif resourceList[num] == tradeToTest then
                directionWeights[i] = directionWeights[i]*3*probability_map[probabilityList[num]]
            end
        end
        local sum = arraySum(directionWeights)
        print('port ', boarderIndex, ' facing ', direction,' to trade ', tradeToTest, ' yields ', sum)
        return sum < 25
    end


    local boarder = deepcopy(oldboarder)
    local returnList = deepcopy(returnList)
    local availableTrades = deepcopy(availableTrades)
    if #boarder == 0 then
        return returnList
    end

    local toTest = table.remove(boarder,1)
    if toTest == 0 then
        return buildPortArray(boarder,availableTrades,table.insert(returnList,0))
    end
    for i,direction in pairs(getCoastalNeighborDirections(tilePositions,boarderPositions,#returnList+1)) do
        for j,trade in pairs(availableTrades) do
            if canPlace(#returnList+1,direction,trade) then
                local theRest = buildPortArray(boarder,availableTrades,table.insert(returnList,{direction,table.remove(availableTrades,j)}))
                if theRest ~= nil then
                    return theRest
                end
                    table.remove(returnList)
            end
        end
    end
    return nil
end

--helper function that will return a list, entries alternate 0 and the next
--boarder position. Used for ports. Every other ocean tile will have a port
--starting TL with either open ocean or port
function buildPortPositionArray(boarder)
    local start = math.random(2)
    local returnArray = {}
    for i = start,#boarder,2 do
        table.insert(returnArray,boarder[i])
    end
    for i = start%2+1,#boarder,2 do
        table.insert(returnArray,i,0)
    end
    return returnArray
end

function placePorts(portArray)
    local placedArray = {}
    for i,tab in pairs(portArray) do
        if tab ~= 0 then
            table.insert(placedArray,spawnObject(tileParams))
            placedArray[#placedArray].setCustomObject(port)
            placedArray[#placedArray].setLock(true)
            --placedArray[#placedArray].setPosition({i,0.96,i})
            placedArray[#placedArray].setPosition({boarderPositions[i][1],0.96,boarderPositions[i][2]})
            placedArray[#placedArray].setRotation({0,tab[1]*60-60,0})
        end
    end
    return placedArray
end

function placeTradeTokens(portArray, portObjectArray)
    print('placeing trades...')
    local tokenArray = {}
    --local available = deepcopy(avail_trade_small)
    local curTradeParams = deepcopy(tradeCustom)
    for index,tab in pairs(portArray) do
        if tab ~= 0 then
            print('placing ', tab[2])
            curTradeParams.image = tradeTokenImages[tab[2]+1]
            table.insert(tokenArray,spawnObject(probabilityParams))
            tokenArray[#tokenArray].setCustomObject(curTradeParams)
            tokenArray[#tokenArray].setName(tradeTokenNicknames[tab[2]+1])
            tokenArray[#tokenArray].setLock(true)
            tokenArray[#tokenArray].scale(0.6)
            tokenArray[#tokenArray].setPosition(portObjectArray[index].positionToWorld(portSnap.position))
            tokenArray[#tokenArray].setRotation({0,tab[1]*60-90,0})
        end
    end
end

--spawn and place terrain tiles given a resource distribution and table
--of coordinates
function placeTerrain(board, coords)
    local b = board
    local placementArray = {}
    for index,resource in pairs(b) do
        placementArray[index] = spawnObject(tileParams)
        if resource == SHEEP then
            placementArray[index].setCustomObject(sheep)
            placementArray[index].setName('sheep')
            --tempSnapPoint = sheepSnap[1].position
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[3]))
        elseif resource == WOOD then
            placementArray[index].setCustomObject(wood)
            placementArray[index].setName('wood')
            --tempSnapPoint = treesSnap[1].position
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[1]))
        elseif resource == CLAY then
            placementArray[index].setCustomObject(clay)
            placementArray[index].setName('brick')
            --tempSnapPoint = claySnap[1].position
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[2]))
        elseif resource == DESERT then
            placementArray[index].setCustomObject(desert)
            placementArray[index].setName('desert')
            --tempSnapPoint = nil
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[6]))
        elseif resource == WHEAT then
            placementArray[index].setCustomObject(wheat)
            placementArray[index].setName('wheat')
            --tempSnapPoint = wheatSnap[1].position
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[4]))
        elseif resource == ORE then
            placementArray[index].setCustomObject(ore)
            placementArray[index].setName('ore')
            --tempSnapPoint = oreSnap[1].position
            placementArray[index].setSnapPoints(concat(tileSnap,resource_spec_snaps[5]))
        else
            print('NO MODEL FOUND...')
            --tempSnapPoint = nil
        end
        placementArray[index].setPosition({coords[index][1],0.96,coords[index][2]})
        placementArray[index].setRotation({0,60*math.random(6),0})
        placementArray[index].setLock(true)
        -- if tempSnapPoint != nil then
        --     table.insert(probabilityPositions, placementArray[index].positionToWorld(tempSnapPoint))
        -- else
        --     print('no snap point found')
        -- end

    end
    return placementArray
end

--------------------------------------------------------------------------------need to reset tried and append it to avail
function getBalancedBoard(resourceList, returnList, triedResource)

    function canPlace(list, resource)
        for i,placedResourceIndex in pairs(getNeighbors(tilePositions, #list+1)) do
            if floatEqual(list[placedResourceIndex],resource,1) then
                return false
            end
        end
        return true
    end

    local resourceList = deepcopy(resourceList)
    local returnList = deepcopy(returnList)
    local triedResource = deepcopy(triedResource)

    if #resourceList == 0 and #triedResource == 0 then
        return returnList
    elseif #resourceList == 0 and #triedResource ~= 0 then
        return nil
    end

    local toTest = table.remove(resourceList, math.random(#resourceList))
    --print('testing resource ', toTest, ' for index ', #returnList +1)
    if canPlace(returnList,toTest) then
        resourceList = concat(triedResource,resourceList)
        triedResource = {}
        --print(#resourceList)
        local theRest = getBalancedBoard(resourceList,table.insert(returnList,toTest),triedResource)
        if theRest ~= nil then
            return theRest
        else
            return getBalancedBoard(resourceList,returnList,triedResource)
        end
    else
        return getBalancedBoard(resourceList,returnList,table.insert(triedResource,toTest))
    end
end


--returns a table of resources randomly placed given a size
--starts TL and goes L-R and T-B
function getRandomBoard(size)
    local returnSet = {}
    local layout = land_small
    local resources = deepcopy(resources_small)
    for i,pos in pairs(layout) do
        table.insert(returnSet,table.remove(resources,math.random(#resources)))
    end
    return returnSet
end


function buildProbList(returnList, resourceList, probByResource)

    function canPlace(currentBoard, num)
        local canPlace = true
        for i, placedProbIndex in pairs(getNeighbors(tilePositions, #currentBoard+1)) do
            if floatEqual(currentBoard[placedProbIndex],num,1) then
                canPlace = false
                break
            end
            if probability_map[num] == 5 then
                if floatEqual(probability_map[currentBoard[placedProbIndex]],5,1) then
                    canPlace = false
                end
            end
        end
        return canPlace
    end


    local returnList = deepcopy(returnList)
    local resourceList = deepcopy(resourceList)
    local probByResource = deepcopy(probByResource)
    if #resourceList == 0 then
        return returnList
    end
    --log(resourceList[1])
    local selectedResource = table.remove(resourceList,1)
    for i,probToTest in pairs(probByResource[selectedResource+1]) do
        if canPlace(returnList, probToTest) then
            table.remove(probByResource[selectedResource+1],i)
            local theRest = buildProbList(table.insert(returnList, probToTest),resourceList,probByResource)
            if theRest ~= nil then
                --log(probToTest)
                return theRest
            end
            table.remove(returnList)
        end
    end
    return nil
end

function getBalancedProbs(probArray)
    local averageReturnFloor = 3
    local averageReturnCeiling = 3.5
    local woodProbs = {}
    local clayProbs = {}
    local sheepProbs = {}
    local wheatProbs = {}
    local oreProbs = {}

    function localProb()
        local availProbs = deepcopy(probArray)
        woodProbs = {}
        clayProbs = {}
        sheepProbs = {}
        wheatProbs = {}
        oreProbs = {}
        local tempSum = 0
        for i = 1,numWood do
            local tempReturn = table.remove(availProbs,math.random(#availProbs))
            tempSum = tempSum + probability_map[tempReturn]
            table.insert(woodProbs, tempReturn)
            if(tempSum > averageReturnCeiling*numWood) then
                return false
            end
        end
        if tempSum < averageReturnFloor*numWood then
            return false
        end
        tempSum = 0

        for i = 1,numClay do
            local tempReturn = table.remove(availProbs,math.random(#availProbs))
            tempSum = tempSum + probability_map[tempReturn]
            table.insert(clayProbs, tempReturn)
            if(tempSum > averageReturnCeiling*numClay) then
                return false
            end
        end
        if tempSum < averageReturnFloor*numClay then
            return false
        end
        tempSum = 0

        for i = 1,numSheep do
            local tempReturn = table.remove(availProbs,math.random(#availProbs))
            tempSum = tempSum + probability_map[tempReturn]
            table.insert(sheepProbs, tempReturn)
            if(tempSum > averageReturnCeiling*numSheep) then
                return false
            end
        end
        if tempSum < averageReturnFloor*numSheep then
            return false
        end
        tempSum = 0

        for i = 1,numWheat do
            local tempReturn = table.remove(availProbs,math.random(#availProbs))
            tempSum = tempSum + probability_map[tempReturn]
            table.insert(wheatProbs, tempReturn)
            if(tempSum > averageReturnCeiling*numWheat) then
                return false
            end
        end
        if tempSum < averageReturnFloor*numWheat then
            return false
        end
        tempSum = 0

        for i = 1,numOre do
            local tempReturn = table.remove(availProbs,math.random(#availProbs))
            tempSum = tempSum + probability_map[tempReturn]
            table.insert(oreProbs, tempReturn)
            if(tempSum > averageReturnCeiling*numOre) then
                return false
            end
        end
        if tempSum < averageReturnFloor*numOre then
            return false
        end
        return not duplicateProbs(deepcopy({woodProbs,clayProbs,sheepProbs,wheatProbs,oreProbs,}))
    end

    local tick = 0
    while not localProb()  do
        tick = tick + 1
    end

    if tick < 500 then
        return{woodProbs,clayProbs,sheepProbs,wheatProbs,oreProbs,{0}}
    else
        print('balancing prob per resource timed out....')
        return{}
    end
end

--randomly distribute probabilities to board
--uses probabilityCustom built by generate terrain
function generateRandomProbs(availableProbs)
    local availProbs = deepcopy(availableProbs)
    local returnArray = {}
    for index,pos in pairs(availableProbs) do
        table.insert(returnArray,table.remove(availProbs,math.random(#availProbs)))
    end
    return returnArray
end

function placeProbs(probList, placedResources, resourceList)
    if(probList==nil) then
        return {}
    end
    local placementArray = {}
    local probCustParams = deepcopy(probabilityCustom)
    local availProbs = deepcopy(probList)
    for i,tile in pairs(placedResources) do
        if(tile.getName() ~= 'desert') then
            local selectedProb = table.remove(availProbs,1)
            placementArray[i] = spawnObject(probabilityParams)
            probCustParams.image = probabilityImages[selectedProb-1-math.floor(selectedProb/7)]
            placementArray[i].setCustomObject(probCustParams)
            placementArray[i].scale(0.5)
            placementArray[i].setPosition(tile.positionToWorld(resource_spec_snaps[resourceList[i]+1][1].position))
            placementArray[i].setRotation({0,180,0})
            placementArray[i].setLock(true)
        else
            table.remove(availProbs,1)
        end
    end
    return placementArray
end


--resourceCards takes center position of row of cards,
--rotation of the row, and num cards per stack
function resourceCards(position, rotation, numCards)
    deck = spawnObject(deckParams)
    deck.setCustomObject(resourceDeck)
    deck.setRotation(rotation)
    local ref = nil
    local oreCard = deck.takeObject({})
    oreCard.setPosition(position)
    local wheatCard = deck.takeObject({})
    wheatCard.setPosition(oreCard.positionToWorld({3,0,0}))
    local woodCard = deck.takeObject({})
    woodCard.setPosition(oreCard.positionToWorld({6,0,0}))
    local sheepCard = deck.takeObject({})
    sheepCard.setPosition(oreCard.positionToWorld({-3,0,0}))
    local brickCard = deck.takeObject({})
    brickCard.setPosition(oreCard.positionToWorld({-6,0,0}))
    for i=1,numCards do
        oreCard.clone().setPosition(position)
    end
    for i=1,numCards do
        wheatCard.clone().setPosition(oreCard.positionToWorld({3,0,0}))
    end
    for i=1,numCards do
        woodCard.clone().setPosition(oreCard.positionToWorld({6,0,0}))
    end
    for i=1,numCards do
        sheepCard.clone().setPosition(oreCard.positionToWorld({-3,0,0}))
    end
    for i=1,numCards do
        brickCard.clone().setPosition(oreCard.positionToWorld({-6,0,0}))
    end
end

--from UI, deletes all objects in the world
function clearBoard()
    list = getAllObjects()
    print('clearing all objects..')
    for index,ob in pairs(list) do
        destroyObject(ob)
    end
end

--helper function to take combine two tables
--concatinates second given to first, returns the result
function concat(a,b)
    local result = {}
    for _,v in pairs (a) do table.insert(result, v) end
    for _,v in pairs (b) do table.insert(result, v) end
    return result
end


--helper function to copy contents of table to another table
function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

--thanks to stackoverflow user hjpotter92 for this function
function FYShuffle(tInput)
    local tReturn = {}
    for i = #tInput, 1, -1 do
        local j = math.random(i)
        tInput[i], tInput[j] = tInput[j], tInput[i]
        table.insert(tReturn, tInput[i])
    end
    return tReturn
end

--helper function for printing table contents
--credit to stackoverflow user Matt
function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end
--return the neighbors as indeces of the provided table that are neighbors
--of the given index
--ie 1's neighbors are 2,4,and 5 of small terrain
function getNeighbors(list, index)
    local test = {}
    local adjacency = getAdjacent(list[index][1],list[index][2])
    for _,adjPoint in pairs(adjacency) do
        for i,tablePoint in pairs(list) do
            if floatEqual(adjPoint[1],tablePoint[1],1) and floatEqual(adjPoint[2], tablePoint[2],1) then
                table.insert(test, i)
            end
        end
    end
    return test
end

function getCoastalNeighborDirections(landList,waterList,waterIndex)
    local returnArray = {}
    for i,neighbor in pairs(getAdjacent(waterList[waterIndex][1],waterList[waterIndex][2])) do
        for _, land in pairs(landList) do
            if floatEqual(land[1],neighbor[1],1) and floatEqual(land[2],neighbor[2],1) then
                table.insert(returnArray,i)
            end
        end
    end
    return returnArray
end

function getCoastalNeighborIndeces(landList,waterList,waterIndex)
    local returnArray = {}
    for i,neighbor in pairs(getAdjacent(waterList[waterIndex][1],waterList[waterIndex][2])) do
        for j, land in pairs(landList) do
            if floatEqual(land[1],neighbor[1],1) and floatEqual(land[2],neighbor[2],1) then
                table.insert(returnArray,j)
            end
        end
    end
    return returnArray
end

--getAdjacent takes x(left-right) and z(forward-back)
--returns table of centers of 6 adjecent hex
--starting tl and going cw
function getAdjacent(x,z)
    local returnArray = {}
    table.insert(returnArray,{x-1.99,z+3.45})
    table.insert(returnArray,{x+1.99,z+3.45})
    table.insert(returnArray,{x+3.98,z})
    table.insert(returnArray,{x+1.99,z-3.45})
    table.insert(returnArray,{x-1.99,z-3.45})
    table.insert(returnArray,{x-3.98,z})
    return returnArray
end

--helper function to compare floats and deal with nil values
--takes two values and a precision (number of decimal places)
--returns true if two values are equivalent within given precision
--does not round
function floatEqual(num1, num2, precision)
    if(num1 ~= nil and num2 ~= nil) then
        return math.floor(num1*(10^precision)) == math.floor(num2*(10^precision))
    elseif num1 == nil and num2 == nil then
        return true
    end
    return false
end

function addArray(array1, array2)
    assert(#array1 == #array2, "arrays are not of equivalent size")
    local returnArray = {}
    for index,_ in pairs(array1) do
        returnArray[index] = array1[index] + array2[index]
    end
    return returnArray
end

function arraySum(array)
    local returnVal = 0
    for _,num in pairs(array) do
        returnVal = returnVal + num
    end
    return returnVal
end

function removeZeros(array)
    local returnTable = {}
    for i,num in pairs(array) do
        if num ~= 0 then
            table.insert(returnTable,num)
        end
    end
    return returnTable
end

function duplicateProbs(probTable)
    if #probTable == 0 then
        return false
    end
    local cur = table.remove(probTable)
    if type(cur) == 'table' then
        return duplicateProbs(cur) or duplicateProbs(probTable)
    else
        for _,num in pairs(probTable) do
            if cur == num then
                return true
            end
        end
    end
    return false or duplicateProbs(probTable)
end
