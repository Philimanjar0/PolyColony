local DistributedAcceptor = require('board.generator.acceptors.DistributedAcceptor')
local TableUtils = require('ge_tts.TableUtils')

local CspSolver = {}

setmetatable(CspSolver, {
    __call = function(_, underlyingGraph, availableColors, randomnessThreshold, totalVertices)
        
        local self = {}

        -- The underlying graph object
        self.underlyingGraph = underlyingGraph
        
        -- Colors and their cooresponding remaining quantities.
        self.availableColors = TableUtils.copy(availableColors)

        -- The acceptor object. This decides if a tile can be assigned at a specific location. This holds the constraint information
        self.acceptor = DistributedAcceptor(totalVertices)

        -- The threshold randomness used when chosing if tiles can be placed the board. 
        -- Higher randomness threshold means less random and more evenly distributed tiles.
        self.randomnessThreshold = randomnessThreshold

        -- This is just a raw list of colors to use as a domain. Each vertex on the solution graph maintains a list of how 
        -- many of each color it is neighboring.
        self.neighboringColors = {}
        for color, quant in pairs(availableColors) do
            self.neighboringColors[color] = 0
        end


        -- The table that contains the solution of the board generation. Relates coordinates of tiles to colors.
        self.solution = {}

        -- Pass the reference of the solution to the acceptor.
        self.acceptor.setSolution(self.solution, 0)

        -- Build the domain of the problem. Each node contains
        --      neighboringColors: The list of colors and cooresponding quantities of neighboring tiles.
        --      assignment: The color assigned to this node. Unassigned is -1.
        for node in pairs(self.underlyingGraph.getNodes()) do
            self.solution[node] = {}
            self.solution[node].neighboringColors = TableUtils.copy(self.neighboringColors)
            self.solution[node].assignment = -1
        end


        function self.setAcceptor(newAcceptor)
            self.acceptor = newAcceptor
        end

        function self.resetFilledBoard()
            self.solution = {}
        end

        function self.getSolution()
            return self.solution
        end

        -- Helper function to get the next unassigned node.
        local function getNext()
            for node,table in pairs(self.solution) do
                if table.assignment == -1 then
                    return node
                end
            end
            return nil
        end

        -- The constraint satisfaction solver. It recursively 
        function self.solveCsp()
            if self.acceptor.areAllSolved() then
                -- Terminal condition. Return the solved board.
                return self.solution
            end
            local nextToAssign = getNext()
            local nextNeighbors = self.underlyingGraph.getNeighbors(nextToAssign)
            -- TODO if performance is bad, do better ordering than just the default.
            -- TODO shuffle the starting order each time this loop is called. Will affect performance but improve game variety
            for color, quant in pairs(self.availableColors) do
                if quant > 0 then
                    -- Dont check colors that are not available anymore.
                    if self.acceptor.accept(color, nextToAssign, self.randomnessThreshold) then
                        self.availableColors[color] = self.availableColors[color] - 1
                        self.acceptor.assignSolution(nextToAssign, color, self.underlyingGraph.getNeighbors(nextToAssign))
                        local nextResult = self.solveCsp()
                        if nextResult then
                            -- If the next assignment is possible, return it.
                            return nextResult
                        else
                            -- If there is no possible assignment for the next tile. Remove the cuurrent tried solution.
                            self.acceptor.removeSolution(nextToAssign, color, nextNeighbors)
                            self.availableColors[color] = self.availableColors[color] + 1
                        end
                    end
                end
            end
            return false
        end
        return self
    end
})

return CspSolver