local AbstractAcceptor = require('board.generator.acceptors.AbstractAcceptor')
local RandomAcceptor = require('board.generator.acceptors.RandomAcceptor')
local TableUtils = require('ge_tts.TableUtils')

CspSolver = {}

local function getNext(partialSolution)
    for node,table in pairs(partialSolution) do
        if table.assignment == -1 then
            return node
        end
    end
    return nil
end

setmetatable(CspSolver, {
    __call = function(underLyingGraph, availableColors)
        self = {}

        self.underlyingGraph = underLyingGraph

        self.availableColors = availableColors

        self.acceptor = AbstractAcceptor()

        -- This is just a raw list of colors to use as a domain. Each vertex will have this list as colors 
        -- that can be assigned without violating the constraints.

        self.uniqueListOfColors = {}
        
        for color, quant in availableColors do
            self.uniqueListOfColors[color] = color
        end

        -- Table relating node tuples to a list of colors
        self.solution = {}

        -- Build the domain of the problem. i,e, available colors
        for node in pairs(self.underlyingGraph.getNodeTuples()) do
            self.solution[node] = {}
            self.solution[node].available = TableUtils.copy(self.uniqueListOfColors)
            self.solution[node].assignment = -1
        end

        function self.setAcceptor(newAcceptor)
            self.acceptor = newAcceptor
        end

        function self.resetFilledBoard()
            self.solution = {}
        end

        function self.getSolution()
            return self.solution
        end

        function self.solveCsp()
            if #self.solution == #self.underLyingGraph.getNodes() then
                return self.solution
            end
            local nextToAssign = getNext(self.solution)
            local nextNeighbors = self.underLyingGraph.getNeighbors(nextToAssign)
            --TODO if performance is bad, do better ordering than just the default.
            for color, quant in pairs(self.availableColors) do
                if quant > 0 then
                    -- Dont check colors that are not available anymore.
                    if self.acceptor.accept() then
                        self.acceptor.assignSolution(self.solution[nextToAssign], color, self.underLyingGraph.getNeighbors(nextToAssign))
                        local nextResult = self.solveCsp()
                        if nextResult then
                            return nextResult
                        else
                            self.acceptor.removeSolution(nextToAssign, color, nextNeighbors)
                        end
                    end
                end
            end
            return false
        end
        return self

        function self.getSolvedBoard()
            local solvedBoard = {}
            for node, table in pairs(self.solution) do
                solvedBoard[node] = table.assignment
            end
            return solvedBoard
        end
    end
})

return CspSolver