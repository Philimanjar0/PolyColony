local AbstractAcceptor = require('polycolony.board.generator.acceptors.AbstractAcceptor')
local RandomAcceptor = require('polycolony.board.generator.acceptors.RandomAcceptor')
local TableUtils = require('ge_tts.TableUtils')

local CspSolver = {}

setmetatable(CspSolver, {
    __call = function(_, underlyingGraph, availableColors)
        
        local self = {}

        self.underlyingGraph = underlyingGraph
        
        self.availableColors = availableColors

        -- This is just a raw list of colors to use as a domain. Each vertex will have this list as colors 
        -- that can be assigned without violating the constraints.

        self.uniqueListOfColors = {}
        
        for color, quant in pairs(availableColors) do
            self.uniqueListOfColors[color] = color
        end

        -- Table relating node tuples to a list of colors
        self.solution = {}

        -- Build the domain of the problem. i,e, available colors
        for node in pairs(self.underlyingGraph.getNodes()) do
            self.solution[node] = {}
            self.solution[node].available = TableUtils.copy(self.uniqueListOfColors)
            self.solution[node].assignment = -1
        end

        self.acceptor = RandomAcceptor(self.solution, 18)

        function self.setAcceptor(newAcceptor)
            self.acceptor = newAcceptor
        end

        function self.resetFilledBoard()
            self.solution = {}
        end

        function self.getSolution()
            return self.solution
        end

        local function getNext()
            for node,table in pairs(self.solution) do
                if table.assignment == -1 then
                    return node
                end
            end
            return nil
        end

        function self.solveCsp()
            if self.acceptor.areAllSolved() then
                return self.solution
            end
            local nextToAssign = getNext()
            local nextNeighbors = self.underlyingGraph.getNeighbors(nextToAssign)
            --TODO if performance is bad, do better ordering than just the default.
            for color, quant in pairs(self.availableColors) do
                if quant > 0 then
                    -- Dont check colors that are not available anymore.
                    if self.acceptor.accept() then
                        self.availableColors[color] = self.availableColors[color] - 1
                        self.acceptor.assignSolution(nextToAssign, color, self.underlyingGraph.getNeighbors(nextToAssign))
                        local nextResult = self.solveCsp()
                        if nextResult then
                            return nextResult
                        else
                            self.acceptor.removeSolution(nextToAssign, color, nextNeighbors)
                            self.availableColors[color] = self.availableColors[color] + 1
                        end
                    end
                end
            end
            return false
        end
        return self
    end
})

return CspSolver