local DistributedAcceptor = require('board.generator.acceptors.DistributedAcceptor')
local TableUtils = require('ge_tts.TableUtils')
local Solution = require('board.generator.solutions.Solution')

local CspSolver = {}

setmetatable(CspSolver, {
    -- __call = function(_, underlyingGraph, availableColors, randomnessThreshold, totalVertices)
    __call = function(_, solution, acceptor, availableColors, underlyingGraph)
        
        local self = {}

        -- The underlying graph object
        self.underlyingGraph = underlyingGraph
        
        -- Colors and their cooresponding remaining quantities.
        self.availableColors = TableUtils.copy(availableColors)

        -- The acceptor object. This decides if a tile can be assigned at a specific location. This holds the constraint information
        self.acceptor = acceptor

        -- The table that contains the solution of the board generation. Relates coordinates of tiles to colors.
        -- self.solution = Solution(self.underlyingGraph, self.availableColors)

        self.solution = solution

        -- Pass the reference of the solution to the acceptor.
        self.acceptor.setSolution(self.solution, 0)

        function self.setAcceptor(newAcceptor)
            self.acceptor = newAcceptor
        end

        function self.resetFilledBoard()
            self.solution = {}
        end

        function self.getSolution()
            return self.solution.solutionNodes
        end

        -- Helper function to get the next unassigned node.
        local function getNext()
            for node,table in pairs(self.solution.getSolution()) do
                if table.assignment == -1 then
                    return node
                end
            end
            return nil
        end

        -- The constraint satisfaction solver. It recursively 
        function self.solveCsp()
            if self.acceptor.areAllSolved() then
                -- Terminal condition. Return the solved board.
                return self.solution
            end
            local nextToAssign = getNext()
            local nextNeighbors = self.underlyingGraph.getNeighbors(nextToAssign)
            -- TODO if performance is bad, do better ordering than just the default.
            -- TODO shuffle the starting order each time this loop is called. Will affect performance but improve game variety
            for color, quant in pairs(self.availableColors) do
                if quant > 0 then
                    -- Dont check colors that are not available anymore.
                    if self.acceptor.accept(color, nextToAssign) then
                        self.availableColors[color] = self.availableColors[color] - 1
                        self.acceptor.assignSolution(nextToAssign, color, self.underlyingGraph.getNeighbors(nextToAssign))
                        local nextResult = self.solveCsp()
                        if nextResult then
                            -- If the next assignment is possible, return it.
                            return nextResult
                        else
                            -- If there is no possible assignment for the next tile. Remove the cuurrent tried solution.
                            self.acceptor.removeSolution(nextToAssign, color, nextNeighbors)
                            self.availableColors[color] = self.availableColors[color] + 1
                        end
                    end
                end
            end
            return false
        end
        return self
    end
})

return CspSolver