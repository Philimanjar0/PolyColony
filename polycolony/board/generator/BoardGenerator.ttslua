-- Coordinate system conventions from https://www.redblobgames.com/grids/hexagons/

local HexGraph = require('board.generator.HexGraph')
local CspSolver = require('board.generator.CspSolver')
local TileUtils = require('polycolony.board.TileUtils')
local TileLibrary = require('polycolony.board.TileLibrary')
local GraphUtils = require('polycolony.board.generator.GraphUtils')
local ObjectUtils = require('ge_tts.ObjectUtils')
local UserPreferences = require('polycolony.UserPreferences')
local TableUtils = require('ge_tts.TableUtils')

local BoardGenerator = {}

setmetatable(BoardGenerator, {
    __call = function(_, boardConfig, edgeLength, boardType)
        local self = {}

        -- Create and populate the HexGraph
        self.hexGraph = HexGraph()

        -- Hex coordinates for the desert to remove that node from the graph. It should not get colored so it should not be in the domain.
        -- Coordinates calculated from https://www.redblobgames.com/grids/hexagons/#range
        local desertX = math.random(boardConfig.SIZE.X[1], boardConfig.SIZE.X[2])
        local desertY = math.random(math.max(boardConfig.SIZE.Y[1], -desertX - boardConfig.SIZE.Y[2]), 
                                    math.min(boardConfig.SIZE.Y[2], -desertX + boardConfig.SIZE.Y[2]))
        local desertCoords = {
            -- The z coordinate is generated based on the x+y+z=0 constraint used for the coordinate system.
            x = desertX,
            z = -desertX - desertY
        }
        
        -- Generate the underlying graph used for CSP solving.
        -- Coordinates calculated from https://www.redblobgames.com/grids/hexagons/#range
        for x = boardConfig.SIZE.X[1], boardConfig.SIZE.X[2] do
            for y = math.max(boardConfig.SIZE.Y[1], -x - boardConfig.SIZE.Y[2]), 
            math.min(boardConfig.SIZE.Y[2], -x + boardConfig.SIZE.Y[2]) do
                -- The z coordinate is generated based on the x+y+z=0 constraint used for the coordinate system.
                local z = -x - y
                self.hexGraph.addNode(x, z)
            end
        end

        -- Remove the desert node from the graph to speed up generation.
        self.hexGraph.removeNode(desertCoords.x, desertCoords.z)

        -- Calcuate the total number of resource to be allocated on the board. Used by the solver to learn if it is done.
        local totalResourceTiles = 0
        for _,val in pairs(boardConfig.RESOURCES) do
            totalResourceTiles = totalResourceTiles + val
        end
        
        -- Generate the board by solving the CSP.
        self.cspSolver = CspSolver(self.hexGraph, boardConfig.RESOURCES, UserPreferences.BOARD_RANDOMNESS, totalResourceTiles)
        self.cspSolver.solveCsp()

        -- Spawn in the respective tiles in game based on the solution. 
        for node, nodeTable in pairs(self.cspSolver.getSolution()) do
            local tileCoords = TileUtils.axialToWorld(GraphUtils.split(node, ";"), 2.3)
            local tileState = TileUtils.tileState(TileLibrary[nodeTable.assignment], tileCoords, {0, math.random(0,5) * 60, 0})
            local tileObject = ObjectUtils.safeSpawnObject(tileState)
        end

        -- Spawn in the desert tile.
        ObjectUtils.safeSpawnObject(
            TileUtils.tileState(
                TileLibrary.DESERT, TileUtils.axialToWorld({desertCoords.x, desertCoords.z}, 2.3), {0,0,0}))

        -- Build the ocean boarder. Loop logic from https://www.redblobgames.com/grids/hexagons/#rings
        local oceanCoords = {boardConfig.SIZE.X[1] - 1, boardConfig.SIZE.Y[2] - 2}
        for i = 1,6 do
            for j = 0,2 do
                ObjectUtils.safeSpawnObject(
                    TileUtils.tileState(
                        TileLibrary.OCEAN, TileUtils.axialToWorld(oceanCoords, 2.3), {0, math.random(0,5) * 60, 0}))
                oceanCoords = GraphUtils.getAllNeighbors(oceanCoords[1], oceanCoords[2])[i]
            end
        end
        
        return self
    end,
})

return BoardGenerator