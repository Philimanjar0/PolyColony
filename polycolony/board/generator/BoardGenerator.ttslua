-- Coordinate system conventions from https://www.redblobgames.com/grids/hexagons/

-- q = x and r = z

local Vector3 = require('ge_tts.Vector3')
local HexGraph = require('board.generator.HexGraph')
local CspSolver = require('board.generator.CspSolver')
local AbstractAcceptor = require('board.generator.acceptors.AbstractAcceptor')
local RandomAcceptor = require('board.generator.acceptors.RandomAcceptor')
local DistributedAcceptor = require('board.generator.acceptors.DistributedAcceptor')
local TileUtils = require('polycolony.board.TileUtils')
local TileLibrary = require('polycolony.board.TileLibrary')
local GraphUtils = require('polycolony.board.generator.GraphUtils')
local ObjectUtils = require('ge_tts.ObjectUtils')
local UserPreferences = require('polycolony.UserPreferences')
local TableUtils = require('ge_tts.TableUtils')

local BoardGenerator = {}

setmetatable(BoardGenerator, {
    __call = function(_, boardConfig, edgeLength, boardType)
        local self = {}

        -- Create and populate the HexGraph
        self.hexGraph = HexGraph()

        -- Hex coordinates for the desert to remove that node from the graph. It should not get colored so it should not be in the domain.
        -- Coordinates calculated from https://www.redblobgames.com/grids/hexagons/#range
        local desertX = math.random(boardConfig.SIZE.X[1], boardConfig.SIZE.X[2])
        local desertY = math.random(math.max(boardConfig.SIZE.Y[1], -desertX - boardConfig.SIZE.Y[2]), 
                                    math.min(boardConfig.SIZE.Y[2], -desertX + boardConfig.SIZE.Y[2]))
        local desertCoords = {
            -- The z coordinate is generated based on the x+y+z=0 constraint used for the coordinate system.
            x = desertX,
            z = -desertX - desertY
        }
        
        -- Generate the underlying graph used for CSP solving.
        -- Coordinates calculated from https://www.redblobgames.com/grids/hexagons/#range
        for x = boardConfig.SIZE.X[1], boardConfig.SIZE.X[2] do
            for y = math.max(boardConfig.SIZE.Y[1], -x - boardConfig.SIZE.Y[2]), 
            math.min(boardConfig.SIZE.Y[2], -x + boardConfig.SIZE.Y[2]) do
                -- The z coordinate is generated based on the x+y+z=0 constraint used for the coordinate system.
                local z = -x - y
                self.hexGraph.addNode(x, z)
            end
        end

        -- Remove the desert node from the graph to speed up generation.
        self.hexGraph.removeNode(desertCoords.x, desertCoords.z)

        -- Calcuate the total number of resource to be allocated on the board. Used by the solver to learn if it is done.
        local totalResourceTiles = 0
        for _,val in pairs(boardConfig.RESOURCES) do
            totalResourceTiles = totalResourceTiles + val
        end

        -- Build the CSP solver for resources.
        -- See the TODO in the CspSolver class to remove these.
        local acceptor = nil
        if boardType == UserPreferences.BOARD.RANDOM then
            acceptor = RandomAcceptor(totalResourceTiles)
        elseif boardType == UserPreferences.BOARD.DISTRIBUTED then
            acceptor = DistributedAcceptor(totalResourceTiles)
        end

        -- Generate the board by solving the CSP.
        self.cspSolver = CspSolver(self.hexGraph, boardConfig.RESOURCES, acceptor)
        self.cspSolver.solveCsp()

        -- Spawn in the respective tiles in game based on the solution.
        for node, nodeTable in pairs(self.cspSolver.getSolution()) do
            local tileCoords = TileUtils.axialToWorld(GraphUtils.split(node, ";"), 2.3)
            local tileState = TileUtils.tileState(TileLibrary[nodeTable.assignment], tileCoords, {0,0,0})
            local tileObject = ObjectUtils.safeSpawnObject(tileState)
        end

        -- Spawn in the desert tile.
        ObjectUtils.safeSpawnObject(
            TileUtils.tileState(
                TileLibrary.DESERT, TileUtils.axialToWorld({desertCoords.x, desertCoords.z}, 2.3), {0,0,0}))        
        
        return self
    end,
})

return BoardGenerator