-- Coordinate system conventions from https://www.redblobgames.com/grids/hexagons/

-- q = x and r = z

local Vector3 = require('ge_tts.Vector3')
local HexGraph = require('board.generator.HexGraph')
local CspSolver = require('board.generator.CspSolver')
local AbstractAcceptor = require('board.generator.acceptors.AbstractAcceptor')
local RandomAcceptor = require('board.generator.acceptors.RandomAcceptor')
local TileUtils = require('polycolony.board.TileUtils')
local TileLibrary = require('polycolony.board.TileLibrary')
local GraphUtils = require('polycolony.board.generator.GraphUtils')
local ObjectUtils = require('ge_tts.ObjectUtils')

local BoardGenerator = {}

setmetatable(BoardGenerator, {
    __call = function(_, boardConfig, edgeLength)
        local self = {}

        -- Create and populate the HexGraph
        self.hexGraph = HexGraph()

        -- Hex coordinates for the desert to remove that node from the graph. It should not get colored so it should not be in the domain.
        local desertCoords = {
            x = math.random(boardConfig.SIZE.X[1], boardConfig.SIZE.X[2]),
            y = math.random(boardConfig.SIZE.X[1], boardConfig.SIZE.Y[2]),
            z = math.random(boardConfig.SIZE.Z[1], boardConfig.SIZE.Z[2])
        }

        -- We do waste a bit of looping to get all the tiles because for each z loop, only one value satisfies the x+y+z=0 constraint.
        -- Not sure how else to do non-symmetric boards right now, who cares though it runs once.
        --TODO make this loop more efficient. calculate one of the values from the other 3
        for x = boardConfig.SIZE.X[1], boardConfig.SIZE.X[2] do
            for y = boardConfig.SIZE.X[1], boardConfig.SIZE.Y[2] do
                for z = boardConfig.SIZE.Z[1], boardConfig.SIZE.Z[2] do
                    if x + y + z == 0 then
                        -- add all the nodes to the underlying graph that fit the layout defined in BoardConfig
                        self.hexGraph.addNode(x, z)
                    end
                end
            end
        end

        -- Remove the desert node from the graph to speed up generation.
        self.hexGraph.removeNode(desertCoords.x, desertCoords.z)
        
        -- Build the CSP solver for resources
        self.cspSolver = CspSolver(self.hexGraph, boardConfig.RESOURCES)
        self.cspSolver.solveCsp()

        for node, nodeTable in pairs(self.cspSolver.getSolution()) do
            -- print("Position: " .. node .. " " .. tostring(nodeTable.assignment))
            local tempVar = TileLibrary[nodeTable.assignment]
            if tempVar ~= nil then
                local tileCoords = TileUtils.axialToWorld(GraphUtils.split(node, ";"), 2.3)
                local tileState = TileUtils.tileState(TileLibrary[nodeTable.assignment], tileCoords, {0,0,0})
                local tileObject = ObjectUtils.safeSpawnObject(tileState)
            end
        end

        --[[
            local cardState = CardUtils.cardState(card, {0, -10, 0})
            local cardObject = ObjectUtils.safeSpawnObject(cardState)
            local cardInstance = CardInstance(card, cardObject)
        ]]--
        
        
        return self
    end,
})

return BoardGenerator