local Object = require('ge_tts.Object')
local ObjectUtils = require('ge_tts.ObjectUtils')
local AssetLibrary = require('polycolony.CardAssetLibrary')

-- We're going to be creating TTS (custom) card objects at runtime for each card in our card library.
-- To do this we need to create a special representation of TTS card object that TTS knows how to
-- spawn.

---@type number
local deckIdCounter = 0

local deckID = {}

--- Returns a new unique ID for provided key value. Simply incremented by 1 for each new deck added.
---@param key CardType
---@return number unique ID
local function getDeckID(key)
    if (deckID.key == nil) then
        deckIdCounter = deckIdCounter + 1
        deckID.key = deckIdCounter
    end
    return deckID.key
end

-- We're just using this `CardUtils` table to group together methods pertaining to cards.
local CardUtils = {}

--- Creates a "custom card" state (data representation) corresponding to a card in our library.
---@param card Card
---@param position tts__VectorShape
---@return tts__CardCustomState
function CardUtils.cardState(card, position)
    
    -- Grab a unique deck ID for our card.
    local deckId = getDeckID(card.type) 
    return {
        -- TTS object type.
        Name = Object.Name.CardCustom,

        -- Nickname to be displayed in TTS tooltip.
        Nickname = card.name,

        -- ge_tts provides a helper to generate a transform state from vector
        Transform = ObjectUtils.transformState({
            position = position,
            rotation = {0, 180, 0},
            scale = {1, 1, 1},
        }),

        -- A card ID is a unique number per card "asset" in a mod. 100x the Deck ID + the card
        -- number (starting at zero) within the deck.
        CardID = deckId * 100 + card.assetIndex,

        -- We also need to describe to TTS how a deck (in this case card) ought to be displayed.
        -- In this case, our card is part of a custom deck/
        CustomDeck = {
            -- Which custom deck?
            [tostring(deckId)] = { -- Note: Although deckIds are numbers, they're stored as strings.
                FaceURL = card.asset.frontUrl, -- The image URLs for our card.
                BackURL = card.asset.backUrl, 

                NumWidth = card.asset.rows, -- This is the number of columns in the deck image
                NumHeight = card.asset.columns, -- This is the number of rows in the deck image

                BackIsHidden = false, -- We use a custom hidden card face.
                UniqueBack = false, -- Every card in this deck has the same back.
            }
        }
        
    }
end

return CardUtils
