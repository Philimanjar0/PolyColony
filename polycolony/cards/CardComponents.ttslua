local WorldLayout = require('polycolony.WorldLayout')
local CardInstance = require('polycolony.cards.CardInstance')
local CardLibrary = require('polycolony.cards.CardLibrary')
local CardType = require('polycolony.cards.CardType')
local CardUtils = require('polycolony.cards.CardUtils')
local TableUtils = require('ge_tts.TableUtils')
local ObjectUtils = require('ge_tts.ObjectUtils')
local CardDropZone = require('polycolony.cards.CardDropZone')
local DropZone = require('ge_tts.DropZone')


local CardComponents = {}


local function spawnCardOfType(cardType, origin, instances, dropZones, facing)
    -- Counter to space out cards properly
    local i = -1
    for _,card in pairs(CardLibrary) do
        -- Just a test for loop to load one of each resource type. Just spawns some stuff
        if card.type == cardType then
            i = i + 1
            --spawn the cards to a unique hidden position far away, they will be brought into their respective zones later
            local position = origin.POSITION
            local rotation = origin.ROTATION
            local cardDropZone,_ = TableUtils.detect(dropZones, 
                function(v,k) return cardType == v.getValidType() end)
            if cardDropZone == nil then
                -- If the card drop zone does not exist that we want for the given type, make it and add it to its respective table
                cardDropZone = CardDropZone({position.x + (position.x + (i * 2.2)) * math.cos(math.rad(rotation.y)), 
                    position.y, position.z + (position.z + (i * 2.2)) * math.sin(math.rad(rotation.y))}, 
                    {rotation.x, -1 * rotation.y + 180, rotation.z}, facing, {2, 5, 3}, card.subtype == nil and card.type or card.subtype)
                table.insert(dropZones, cardDropZone)
            end
            for j = 1,card.number do
                -- build and spawn all of the cards in their respective quantities
                local cardState = CardUtils.cardState(card, {0, -10, 0})
                local cardObject = ObjectUtils.safeSpawnObject(cardState)
                local cardInstance = CardInstance(card, cardObject)
                table.insert(instances, cardInstance)
                cardDropZone.drop(nil, cardInstance.getObject())
            end
            
        end
    end
end


setmetatable(CardComponents, {
    ---@param worldLayout nil | GameSizeOrigin
    __call = function(_,worldLayout)

        self = {}
        
        -- Table to keep track of instances and zones
        ---@type CardInstance[]
        local cardInstances = {}
        ---@type CardDropZone[]
        local cardDropZones = {}

        ---@type CardInstance[]
        function self.getCardInstances()
            return cardInstances
        end

        ---@type CardDropZone[]
        function self.getCardDropZones()
            return cardDropZones
        end

        --Spawn the cards of all types
        --TODO automate this probably
        spawnCardOfType(CardType.RESOURCE, worldLayout.RESOURCE_CARDS, cardInstances, cardDropZones, DropZone.Facing.UP)
        spawnCardOfType(CardType.DEVELOPEMENT, worldLayout.DEVELOPEMENT_CARDS, cardInstances, cardDropZones, DropZone.Facing.DOWN)

        --Get the zone we want to shuffle in, wait for the cards to be dropped in, then shuffle
        local shuffleZone,_ = TableUtils.detect(cardDropZones, function(v,k) return CardType.DEVELOPEMENT == v.getValidType() end)
        Wait.condition(function() shuffleZone.getDeckContainer().shuffle() end, function() return shuffleZone.getDeckContainer() ~= nil end)
    end
})



return CardComponents
